import numpy as np
import matplotlib.pyplot as plt
import collections

#The Plotter class will plot the metrics generated by the Evaluator class on all
#specified missing data fractions. The class requires an array containing the
#missing data fractions and an array containing the average IC-scores (or other scores?)
#for each missing data fraction.
class Plotter:
    def __init__(self):
        self.frac_of_miss_array = []
        self.dictarray = []

    #Add_score will add fraction data to the frac_of_miss_array list
    #Add score will also add a dictionary with the technique as key and corresponding value used for plotting.
    #For example{'f1-score',10} to the dictarray, this will be used in plot performance.
    def add_score(self, fraction, mean):
        self.frac_of_miss_array.append(fraction)
        self.dictarray.append(mean)

    #Plot_performance is able to plot multiple times depending on the amount of unique keys in the dict_array
    #This will count the amount of fractions and plot the mean and standard deviation for each fraction
    #Plotter will also give the corresponding x-as and y-axis names to the corresponding technique used
    def plot_performance(self):
        #self.frac_of_miss_array = [40,20,60,80,100]
        #self.dictarray =  [{'f-score': 0.269029233330571, 'precision': 0.4749822741375965}, {'f-score': 0.15582532642287256, 'precision': 0.36122322021123104}, {'f-score': 0.3570710024703145, 'precision': 0.5322192152383756}, {'f-score': 0.42327070954837404, 'precision': 0.5532451659817748}, {'f-score': 0.47918747114661814, 'precision': 0.5655777387140406}]

        uniquelist = []
        for key in self.dictarray[0].keys():
            if key not in uniquelist:
                uniquelist.append(key)

        fractions = sorted(set(self.frac_of_miss_array))
        for value in uniquelist:
            newarray = [d[value] for d in self.dictarray]
            amount_of_runs = self.frac_of_miss_array.count(100)
            means = {}
            stdevs = {}

            for round in range(0,len(self.frac_of_miss_array),amount_of_runs):
                acround = self.frac_of_miss_array[round]
                means[acround] = np.mean(newarray[round:round+amount_of_runs])
                stdevs[acround] = np.std(newarray[round:round+amount_of_runs])

            means = collections.OrderedDict(sorted(means.items()))
            stdevs = collections.OrderedDict(sorted(stdevs.items()))
            fig,ax = plt.subplots()
            means = np.asarray(list(means.values())[::-1])
            stdevs = np.asarray(list(stdevs.values())[::-1])
            ax.errorbar(np.arange(len(fractions)), means, stdevs, lw=3, fmt='ok')
            ax.set_xticks(np.arange(len(fractions)))
            ax.set_xticklabels([100-x for x in fractions[::-1]])
            ax.plot(means)
            ax.set_ylabel(value)
            ax.set_xlabel('Percentage of missing data')
            ax.set_title("PFP-model " + value + " under varying missing data fractions")
            fig.savefig(value + '.png')